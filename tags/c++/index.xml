<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tangly Components â€“ C&#43;&#43;</title>
    <link>https://blog.tangly.net/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on tangly Components</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 14 Dec 2023 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="https://blog.tangly.net/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Blog: Bus Sensors and Actuators</title>
      <link>https://blog.tangly.net/blog/2023/bus-sensors-and-actuators/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tangly.net/blog/2023/bus-sensors-and-actuators/</guid>
      <description>
        
        
        &lt;div class=&#34;openblock float-group&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;div class=&#34;imageblock left&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;../pics/2023-12-05-head.jpg&#34; alt=&#34;2023 12 05 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Your embedded system has a set of sensors and actors.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Some sensors and actors are connected to a bus.
Typical buses are &lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;Serial Peripherical Interface&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Bluetooth&#34;&gt;Bluetooth&lt;/a&gt;, or &lt;a href=&#34;https://en.wikipedia.org/wiki/I%C2%B2C&#34;&gt;I2C&lt;/a&gt; standards.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The bus is a shared medium used to communicate with a set of external active or passive components.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Which design rules shall you follow when designing sensors and actors using a bus architecture?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Do you need to consider threading design?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Should you use synchronous or asynchronous communication?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Should you provide queues for sending and receiving messages?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_synchronous_sending&#34;&gt;Synchronous Sending&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Your application can always send messages to a bus synchronously.
These messages are in general commands to physical devices connected through the bus.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_synchronous_unbuffered_sending&#34;&gt;Synchronous Unbuffered Sending&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The send function is a blocking operation until the message is transformed into a frame and sent over the bus.
You should select this approach only if the frame creation and the bus frame transmission is fast.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Beware that bus contention can slow down the frame transmission.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;I do not recommend this approach if you send burst of messages or messages with bigger payloads.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;The approach works well for transmitting irregular short frames and is simple to implement.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock caution&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-caution&#34; title=&#34;Caution&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Analyze the application call stack for all synchronous sending operations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;If some driver functions use blocking calls such as polling waits, the thread, the process and in the worst case, the processor core can be blocked until the call returns.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;If the instruction is a slow initialization request, the system freezes for tens of seconds.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_asynchronous_buffered_sending&#34;&gt;Asynchronous Buffered Sending&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Modern bus drivers are able to buffer messages and return immediately.
Often &lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt; drivers are implemented with a transmission queue.
This approach provides asynchronous processing of a synchronous transmission request.
The caller still has to handle the case when the queue is full.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Beware that transmission errors are not reported back synchronously to the caller.
An asynchronous error can be reported through a callback function.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;This approach requires a &lt;strong&gt;thread&lt;/strong&gt; to process the queue.&lt;/em&gt;
&lt;em&gt;The processing thread is either part of the bus driver or part of the application.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Microcontrollers sometimes implement the thread as an interrupt service routine.&lt;/em&gt;
&lt;em&gt;I would try to avoid the interrupt routine approach if you have a RTOS available.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;This approach scales well for hundreds of devices and thousands of messages per second.&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;The sole limitation is the bus bandwidth.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_asynchronous_receiving&#34;&gt;Asynchronous Receiving&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Please never use a synchronous receiving operation approach.
If you do so, you will block the thread until a message is received.
The waiting time is unpredictable.
If the sending function call graph also handles the sending of the message, you will end up in a deadlock.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This is a major design rule.
You must at least once break the synchronous application calling sequence of sending and receiving frames.
Therefore, you need at least two threads in your solution.
&lt;em&gt;One application thread and one bus driver thread.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_asynchronous_callbacks&#34;&gt;Asynchronous Callbacks&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The bus driver can call a callback function when a message is received.
The asynchronous called function is executed in the context of the bus driver.
Therefore, the callback function shall delegate further processing to another thread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://opensource.lely.com/canopen/&#34;&gt;lely CANOpen&lt;/a&gt; asynchronous callback when a PDO is written in the memory of the device representation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;The documentation clearly states the user is responsible to provide needed threads for processing.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The design of the &lt;a href=&#34;https://opensource.lely.com/canopen/&#34;&gt;lely CANOpen&lt;/a&gt; is an example of shared memory implementation.
The device state is replicated in the local application.
The bus receives frames and updates the local device state objects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Changes are propagated to the application with registered asynchronous callbacks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/CANopenNode/CANopenNode&#34;&gt;CANopenNode&lt;/a&gt; is another example of a &lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt; driver.
All code of the &lt;a href=&#34;https://github.com/CANopenNode/CANopenNode&#34;&gt;CANopenNode&lt;/a&gt; driver is non-blocking.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The callback shall not block the bus driver thread.
It should hand over the payload to another thread for further processing.
The handover is easily done by sending a message to the processing thread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;This approach is implemented through the actor model.&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;All realtime operating systems support this approach through tasks and message queues.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_performance&#34;&gt;Performance&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Use a synchronous calling sequence for all sending operations only if the bus frame transmission is fast.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Break a synchronization calling sequence for all receiving operations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The actor model is an ideal solution for asynchronous message processing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph text-center&#34;&gt;
&lt;p&gt;&lt;span class=&#34;image text-center&#34;&gt;&lt;img src=&#34;../pics/2023-12-05-can.png&#34; alt=&#34;2023 12 05 can&#34;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The &lt;a href=&#34;https://opensource.lely.com/canopen/&#34;&gt;lely CANOpen&lt;/a&gt; design is based on a set of clever decisions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The implementation is completely passive.
The library does not perform any I/O besides maybe reading some files from the disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;It does not create threads nor does it access the system clock.
Instead, it relies on the user to send and receive bus frames and update the clock.
This allows the library to be easily embedded in a wide variety of applications.
&lt;em&gt;This implies that the user shall provide at least one thread to run the library.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The library is also &lt;strong&gt;asynchronous&lt;/strong&gt;.
Issuing a request is &lt;strong&gt;always&lt;/strong&gt; a non-blocking operation.
If the request is confirmed, the API accepts a callback function which is invoked once the request completes with success or failure.
This allows the stack to run in a single thread, even when processing dozens of simultaneous requests.
This configuration is not uncommon for a master node.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Threading is delegated to the user of the driver.
The calling application is responsible for creating threads and protecting shared resources accessed through the callbacks.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock text-center kroki-format-svg kroki&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;https://kroki.io/plantuml/svg/eNq1lE1vwjAMhu_9FT6OQ5HIEU2Iw7TbLuzKDiE1JVqbsMRAf_4cQkv4aIXEdqga2bH9-rHbuSfpaFdXWbblg1Z6Kw3BhyXrJhemN7e_vSKyTCrSe0nYxsQX5LMQAVPwaIoPX77UvhwlztNpCgYbCv5RVuB1LmP5XOGapsAu68Dhzw49AW3wmFibEuwaJKx2fmlq9F6WCNIUcJCawJpjeuDa40RpaIWf1zz_YgFrJ2tcoEK9xyLYz9pd8x6crO2oxOlyw1K2ziquxGJiTMwwbkO7zpSsqpVU37H1pLtQ_4qbiGjEEDfRZReD3MSF2j8A9xS5lIq4oXIRRGlQns-6Gp9oqO9q2is5aXzN-s8TuUkzPIfJvRU9DXzRRN7PLnG7P2EWLXllDUlteCxLE-yuiZL_Y5eHJ_L4nnYJ7vHpW9Ynwx_Z9ZQvHWzL2PdCXvZAnvOHwr_GX096uoo=&#34; alt=&#34;svg&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The operation &lt;em&gt;sendMsg&lt;/em&gt; simply adds a message to the driver mailbox.
The operation &lt;em&gt;callback&lt;/em&gt; similarly adds a message to the motor actor mailbox.
These operations are fast and non-blocking.
Shared resources are the mailboxes.
The RTOS explicitly protects these objects against concurrent modifications.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The callback mechanism shall implement a selector.
The callback function shall dispatch the message to the correct actor mailbox.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The selector is a simple mapping between the device identifier and the actor object if exactly one actor is responsible for the device.
Otherwise, a more complex registration mechanism mapping a list of actors to a device identifier is required.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Both approaches are implemented with a few tens of source code lines.
The C++ or Java standard libraries provide the required data structures and algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The activation blocks show when a thread is active in a single core processor.
If multiple cores are available to the application, the threads can run in parallel when messages are delivered in actor mailboxes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;In both cases, most of the time, actors are suspended waiting for the next message.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_lessons_learnt&#34;&gt;Lessons Learnt&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Do not ignore threading design when designing sensors and actors using a bus architecture.
Bus architectures are common in embedded systems.
Classical buses are &lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;Serial Peripherical Interface&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/I%C2%B2C&#34;&gt;I2C&lt;/a&gt; standards.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Future Tesla cars will use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt; bus to connect all sensors and actors.
&lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt; is discarded as a legacy bus.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Subsystems will be connected through a &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt; switch and have local processing capabilities.
The latency is below 1 millisecond and is suitable for control by wire approaches.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Power is provided through a &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt; cable and &lt;a href=&#34;https://en.wikipedia.org/wiki/Power_over_Ethernet&#34;&gt;Power over Ethernet&lt;/a&gt;.
The standard voltage for the whole car is 48V.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The approach tremendously simplifies the wiring of the car.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Multiple devices connected to a bus are per nature asynchronous.
You cannot predict when a device will send a message.
Therefore, the reception and processing of a received message must be asynchronous and run in a separate thread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Always provide send and receive queues for sending and receiving messages for sophisticated devices.
The queues are used to decouple the bus driver from the application.
All receive and transmit operations are asynchronous.
This design implies asynchronous handling of protocol error codes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Small embedded systems shall use the RTOS provided primitives for communication between the driver and the application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Do not use abstraction layers to isolate the used realtime kernel.
It makes the code more complex and less efficient.
Modern development environments with powerful refactoring tools make the change of the RTOS simple.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Be honest.&lt;/em&gt;
&lt;em&gt;You seldom replace the selected RTOS with another one in your device family.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;If you have a complex realtime system, evaluate using a linux based operating system.&lt;/em&gt;
&lt;em&gt;Use linux design patterns to implement your application.&lt;/em&gt;
&lt;em&gt;Training will be easier.&lt;/em&gt;
&lt;em&gt;Numerous external suppliers can provide support.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_links&#34;&gt;Links&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist bibliography&#34;&gt;
&lt;ul class=&#34;bibliography&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-architecture-principles&#34;&gt;Agile Architecture Principles&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-code-is-clean-code&#34;&gt;Agile Code is Clean Code!&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-architecture-within-scrum/&#34;&gt;Agile Architecture within Scrum&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/agile-component-design&#34;&gt;Agile Component Design&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/legacy-systems-refactoring&#34;&gt;Legacy Systems Refactoring&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/how-agile-collaborators-learn&#34;&gt;How Agile Collaborators Learn&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Sensors and Actuators</title>
      <link>https://blog.tangly.net/blog/2023/sensors-and-actuators/</link>
      <pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tangly.net/blog/2023/sensors-and-actuators/</guid>
      <description>
        
        
        &lt;div class=&#34;openblock float-group&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;div class=&#34;imageblock left&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;../pics/2023-12-04-head.jpg&#34; alt=&#34;2023 12 04 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Embedded design maps domain abstractions to the underlying hardware.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A temperature sensor is a domain abstraction of a physical hardware temperature sensor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A valve is a domain abstraction of a physical hardware valve.
A physical valve can be a simple opened-closed device, or a proportional device.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The microcontroller board reads the temperature sensor through an I2C or SPI bus.
It controls the valve through a GPIO, a PWM or a CAN bus controller.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;These hardware components map the domain object to the electronics controlling the physical device.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_model&#34;&gt;Model&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The C++ declaration of a valve object could be:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock text-center kroki-format-svg kroki&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;https://kroki.io/plantuml/svg/eNp9kEFLAzEQhe_7K4YepIu0oN4iFeoeqmDdgKBHidtpCaSZJYnbQ-l_d7PG3ejG5pS8N_lm3lh0YLEWRjgywFiWVUpYC2vaoGLsVagGS11ut3DMoD2X0JDcANWop_ltLFWKLA7aB5ECacuuECrS1n1bMxig006PhIscFtB2RoeheFThe3fTLs7-PqWScEM7g9bKBhN5PqV2N9fvLg_Oz7tz21_JHBEynieSz2aK69LJ_iH1-R6WT4yt-GMJx1Ms8bf1H6VYPheknSGl0HgvmPcvPOxnVUvyxvCYz--iBUcGzWByNYGuMYNdK41x_LDvaf6egnk9sPzEDOrDfkwqhO5J_t6Tou0MbuD9zsugEvoLO2byRA==&#34; alt=&#34;device-model&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The designers should decide if a &lt;em&gt;progressive valve&lt;/em&gt; is a kind of &lt;em&gt;on/off valve&lt;/em&gt; or not.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;All instances of the namespaces &lt;em&gt;HAL&lt;/em&gt; and &lt;em&gt;BSP&lt;/em&gt; are static and created when the application starts.
Our machines are not hot-pluggable.
All components are wired and fixed with screws.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Relations between objects are defined through constructor parameters.
This approach is a clean and legible &lt;a href=&#34;https://en.wikipedia.org/wiki/Dependency_injection&#34;&gt;Dependency Injection&lt;/a&gt; implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The algorithms should ideally only access the abstractions defined in the &lt;em&gt;model&lt;/em&gt; namespace.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock caution&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-caution&#34; title=&#34;Caution&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The instantiation of objects should define the initialization of abstractions and the underlying physical devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Do we start our system and bring all devices to a well-defined initial state?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Or do we start our system, retrieve the state of all devices and initialize our objects accordingly?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This approach is only possible if each hardware component has sensors providing its current state.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_c_approach&#34;&gt;C++ Approach&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A physical device shall be mapped to a C++ class.
Instances of the class map to existing devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Therefore, the copy constructor and the copy operator should be disabled.
The physical devices are defined through the machine the software controls.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The software accesses the physical device through an electronics interface such as a GPIO, PWM or CAN controller.
The mapping between the electronic component and the physical device is hardwired at construction.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;rouge highlight&#34; style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;&lt;code data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color: #cf222e&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #953800&#34;&gt;ValveOnOff&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color: #0550ae&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;open&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;close&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color: #cf222e&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;isOpen&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #0550ae&#34;&gt;private:&lt;/span&gt;
    &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;ValveOnOff&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #cf222e&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;ValveOnOff&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #0550ae&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;delete&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;;&lt;/span&gt;                           &lt;i class=&#34;conum&#34; data-value=&#34;1&#34;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    &lt;span style=&#34;color: #cf222e&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;ValveOnOff&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #cf222e&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;ValveOnOff&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #0550ae&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;delete&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;;&lt;/span&gt;          &lt;i class=&#34;conum&#34; data-value=&#34;2&#34;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    &lt;span style=&#34;color: #cf222e&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;_opened&lt;/span&gt; &lt;span style=&#34;color: #0550ae&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #953800&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;;&lt;/span&gt;                                             &lt;i class=&#34;conum&#34; data-value=&#34;3&#34;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;colist arabic&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;1&#34;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;A physical device cannot be replicated.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;2&#34;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;A physical device cannot be copied.&lt;br/&gt;
You should evaluate if a default constructor does make sense.
Often the constructor needs other objects connecting the abstraction to the hardware.
This pattern is a hand-coded dependency injection through constructor parameters.&lt;br/&gt;
The default move constructor and move operator can be useful.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;3&#34;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;Imply that the application resets the system when booting.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Constant mapping between the electronic wiring and logical representation shall be provided.
The application should only need to change the mapping when the hardware layout is changed or a microcontroller revision is used.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_interrupt_routines&#34;&gt;Interrupt Routines&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Output devices do not need interrupts.
A driver provides a function to output the new value on the electronics.
As an example, the function writes the new value to a memory-mapped register.
The designer is responsible to avoid concurrent access to the register.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Input devices should always support interrupts.
Otherwise, the application must poll registers to detect changes.
Polling is cumbersome and expensive.
Either the programmer guesses a polling frequency and misses sometimes data.
Or he chooses a high-frequency sampling rate and wastes computing resources.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sidebarblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
Interrupt routines are written in &lt;em&gt;C&lt;/em&gt; or in &lt;em&gt;assembler&lt;/em&gt;.
The C++ language is not supported in interrupt routines.
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Three major interrupt approaches exist:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The interrupt routine reads the new value of the sensor and stores the data at a defined location.
The application accesses the sensor stored value when needed.&lt;/p&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This approach decouples the application from the external sensors.
The drawback is that the program is not informed when a new value is received.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The interrupt routine reads the new value and sends the value as a message to interested parties.&lt;/p&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The approach is a reactive system triggering the application each time input data is received.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The interrupt routine calls a callback function.
The callback function is a function pointer to a static C++ function and often has the reference of the object abstracting the sensor.
Below is a potential implementation of the callback function and callback registration is shown.&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;rouge highlight&#34; style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;&lt;code data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color: #6e7781&#34;&gt;/**
 * @brief Register a callback function to be called when data is received.
 * @param callback The callback function.
 * @param self The reference to the object.
 */&lt;/span&gt;
&lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #8250df&#34;&gt;registerCallback&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;callback&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;);&lt;/span&gt;

&lt;span style=&#34;color: #cf222e&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #953800&#34;&gt;Sensor&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color: #0550ae&#34;&gt;public:&lt;/span&gt;
&lt;span style=&#34;color: #6e7781&#34;&gt;/**
 * @brief Declares the static callback function.
 * @param self The reference to the object.
 * @param data The data received.
 * @param length The length of the data.
 */&lt;/span&gt;
 &lt;span style=&#34;color: #cf222e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;callback&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;Sensor&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;self&lt;/span&gt; &lt;span style=&#34;color: #0550ae&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;Sensor&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&amp;gt;&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;callback&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #6e7781&#34;&gt;/**
 * @brief Object callback function.
 * @param data The data received.
 * @param length The length of the data.
 */&lt;/span&gt;
&lt;span style=&#34;color: #cf222e&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #8250df&#34;&gt;callback&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color: #0550ae&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #cf222e&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6e7781&#34;&gt;// 1. do something with the data. If the sensor is a thread, protect the object data with a mutex or a lock.&lt;/span&gt;
    &lt;span style=&#34;color: #6e7781&#34;&gt;// 2. if the sensor is an actor, create a message with the payload and send it to own mailbox.&lt;/span&gt;
&lt;span style=&#34;color: #24292f;background-color: #f6f8fa&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The interrupt routine or the underlying hardware can handle sensor inputs in two ways:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Data is retrieved regularly.
This synchronous approach gives a rhythm to the system but often uses computing resources without gains.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Data is retrieved when a value has changed.
Either the hardware detects the change or the interrupt routine compares the received data with the stored value.&lt;/p&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This approach is purely reactive.
Algorithms are only triggered when the external system has changed.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I recommend interrupt triggering input data gathering and reacting to input &lt;strong&gt;changes&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This design approach minimizes microcontroller resource consumption and simplifies the control algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_tasks_and_synchronization&#34;&gt;Tasks and Synchronization&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_actuators&#34;&gt;Actuators&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Actuators are often plain old objects.
Modern microcontrollers provide memory-mapped registers to propagate the value to the actuator hardware.
The update operation often writes a new value to a memory-mapped register.
The writing into one register is atomic and does not need additional synchronization.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;If the update operation is more complex and writes multiple registers, the operation should be protected by a mutex.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Beware that mutexes can create deadlocks.
The cleanest approach is to use mutexes with priority inheritance.
Therefore, a task will never have to wait for a lower priority task to release a lock or a mutex.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Another trick is to set all writing tasks to the same priority.
This guarantees that an update operation is not interrupted by another task requesting the same resource.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock caution&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-caution&#34; title=&#34;Caution&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;You could also implement the actuator with a tread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This approach is often overkill.
It complicates unnecessary application design.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_sensors&#34;&gt;Sensors&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Sensors shall always be implemented as a thread.
Otherwise, a client calling an actuator with a synchronous call and waiting for a sensor result will block the whole system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Another trick is to use an interrupt routine to trigger the sensor reading and publish the data on a message queue.
The interrupt routine takes the role of the thread.
This guarantees that clients are not blocked by the sensor reading because they get the data asynchronously.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_lessons_learnt&#34;&gt;Lessons Learnt&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Try to define the simplest model to implement your features.
Follow the &lt;a href=&#34;https://en.wikipedia.org/wiki/KISS_principle&#34;&gt;Keeep It Simple, Stupid&lt;/a&gt; principle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Model the physical world.
A valve, a GPIO, a CAN controller are real things.
Model them.
Do not try to hide things.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The introductory book &lt;em&gt;Realtime C++&lt;/em&gt; [&lt;a href=&#34;#realtime-cpp&#34;&gt;1&lt;/a&gt;] is a rigorous introduction how to program microcontrollers in C++.
You learn how to access hardware resources from C++ and what are the costs of various C++ constructs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Use the actor pattern to implement thread communication &lt;a href=&#34;#distributed-asynchronous-systems&#34;&gt;[distributed-asynchronous-systems]&lt;/a&gt; &lt;a href=&#34;#actors-in-cpp&#34;&gt;[actors-in-cpp]&lt;/a&gt; &lt;a href=&#34;#actors-cmsis-cpp&#34;&gt;[actors-cmsis-cpp]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_links&#34;&gt;Links&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist bibliography&#34;&gt;
&lt;ul class=&#34;bibliography&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-architecture-principles&#34;&gt;Agile Architecture Principles&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-code-is-clean-code&#34;&gt;Agile Code is Clean Code!&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-architecture-within-scrum/&#34;&gt;Agile Architecture within Scrum&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/agile-component-design&#34;&gt;Agile Component Design&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/legacy-systems-refactoring&#34;&gt;Legacy Systems Refactoring&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/how-agile-collaborators-learn&#34;&gt;How Agile Collaborators Learn&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_references&#34;&gt;References&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a id=&#34;realtime-cpp&#34;&gt;&lt;/a&gt;[1] C. Kormanyos, &lt;em&gt;Real-Time C++ Efficient Object-Oriented and Template Microcontroller Programming&lt;/em&gt;. Springer Berlin / Heidelberg, 2021 [Online]. Available: &lt;a href=&#34;https://www.amazon.com/dp/B099J441CH&#34; class=&#34;bare&#34;&gt;https://www.amazon.com/dp/B099J441CH&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Command Interpreter</title>
      <link>https://blog.tangly.net/blog/2023/command-interpreter/</link>
      <pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tangly.net/blog/2023/command-interpreter/</guid>
      <description>
        
        
        &lt;div class=&#34;imageblock left&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;../pics/2023-12-03-head.jpg&#34; alt=&#34;2023 12 03 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Most digital products have a command interpreter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;External systems send requests to the system and often await an answer.
A command interpreter can model this behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The channels used to transmit requests and return answers are variable.
Messages can be transmitted other various buses and protocols.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;An operator can send a command over a &lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;Serial Peripherical Interface&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Bluetooth&#34;&gt;Bluetooth&lt;/a&gt; connection.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A regular command line interpreter inputs commands as a string containing a request and associated parameters.
The answer is displayed as a string.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The processed commands are the instructions executed on the machine.
They are independent of the transmission layer and communication protocol.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;How could you design such a versatile interface using modern software constructs from Java or C++?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Which design delegates most of the validation to the compiler
&lt;sup class=&#34;footnote&#34;&gt;[&lt;a id=&#34;_footnoteref_1&#34; class=&#34;footnote&#34; href=&#34;#_footnotedef_1&#34; title=&#34;View footnote.&#34;&gt;1&lt;/a&gt;]&lt;/sup&gt;?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_command_descriptors_and_commands&#34;&gt;Command Descriptors and Commands&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A description of a command could be encoded in a set of classes defining a bounded domain.
This approach is often used in command line interpreters.
It works well, but the compiler will not validate the descriptors.
The solution does not well integrate with modern communication protocols such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Protocol_Buffers&#34;&gt;Protocol Buffers&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A modern approach would be to encode the command universe as a sealed class hierarchy in Java.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A similar approach could be based on a variant template instance in C++.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The key concept is to encode the command structure into declarations instead of defining a domain model to describe them.
The sole drawback of this approach is that you cannot dynamically add a command type.
You have to declare a new class and compile the program
&lt;sup class=&#34;footnote&#34;&gt;[&lt;a id=&#34;_footnoteref_2&#34; class=&#34;footnote&#34; href=&#34;#_footnotedef_2&#34; title=&#34;View footnote.&#34;&gt;2&lt;/a&gt;]&lt;/sup&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock text-center kroki-format-svg kroki&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;https://kroki.io/plantuml/svg/eNqVUktLAzEQvu-vGHpSwQWvtiy0CiL0Vm_iYZpM22AyKUlEofjfTbIPd2tX2j3sbmaS7zVRHMhtUBA8GAlwKCA-igMoeXU9zatVcIq3wGioLa2t1YQMO_Rz9p_kUuO7KFSHtiS5JZcwZzNPqElWFdBXIJY-Ux3idqHR59XC2vcXh-xRBGU5nnEkrEtnlNlrMsTB9zBrmXMh7AeHZwkbZ830qBZsXVlagfoRA4GMr2aXSZsA82fgMkSN2UqtLQlL5Z6gmhs7nubvQuDG9GqvVbjceSPr9a3n_Lc25jySj9GWZdUCtAqbJBeokeNAz03gn7jXNdQwhScK40xnDf8kPQ48_yW5uYXJ3eTY5D1gvs5dUIPRlGUSPJphr3_CVN38ASioHqU=&#34; alt=&#34;commands&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock important&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-important&#34; title=&#34;Important&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The sealed class hierarchy defines the command types and their parameters.
Each command type is defined through a class definition.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Instances of a command type are commands.
Each command is defined through an instance of a class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The sealed structure guarantees that the compiler will mark all code segments needing edition when a new command type is added.
The sealed class structure and the pattern matching approach is a compiler-validated visitor pattern.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;We decided to store the result of a query into an answer object.
A computed answer can have a reference to the query initiating the processing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;You can pack the result into a future wrapper to support asynchronous command processing.
The interpreter itself behaves as a synchronous command processor matching answers to the related query command.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_interpreters_and_dispatcher&#34;&gt;Interpreters and Dispatcher&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The interpreter is quite simple to realize.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;It processes all commands it is in charge of.
An interpreter is in charge of one or more command sets with a specific group identifier.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A second responsibility is to build a command object based on input data.
It parses the input and generates the command instance representing the received data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Object-oriented approach states that you should not mix the received data with the internal command classes.
Do not inherit from any classes defined in the channel abstraction.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Domain-driven design approach clearly states the channels are interfaces to a bounded domain.
No abstraction defined in the interface layer should pollute the domain model.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The dispatcher delegates the processing to multiple interpreters.
Each subsystem can provide their interpreter to execute commands specific to the bounded domain.
The dispatching criteria is either a group identifier or an interface marker.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock text-center kroki-format-svg kroki&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;https://kroki.io/plantuml/svg/eNp9UU1PwzAMvedXWDulaJs4w7ET0m5IcEMcvNTrIrVJ5YQvVfvvOF3L2lLIIZHz7OdnP-si8RENQV4X-xQ0THIDtArkHLyvCB0YdI_sDYWgrYtQsn9rMtWlSCE0yIH0U2TrypdXiPQZsxl4-IokUIER-8JrOqMLR8-1TummLi61fcUC2sHv3gp3L6qDfF2jK9apaX5C56gCc3kzdVbKVBhCAnc2NBjNScZsr1RMpQ0yup5uYg2jgReT86HHL1kC6j_ETGXcbDawut1u3Wruw11qP0RBKTs2bCBux_tiwmInW9YjuR9sI3WfExsE_hnuwfN_HiXWZ7FVZ_cz2u53wfoJ8ww_fwPMxtBc&#34; alt=&#34;command-interpreter&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;A channel receives and transmits command data.
The channel should be able to extract the message group from a raw message.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Why should we support multiple channels to propagate commands?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;An operator would input commands as text on a command line.
An external software system would send commands through a bus such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;Serial Peripherical Interface&lt;/a&gt;.
Multiple channels are a requirement for a versatile command interpreter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I recommend &lt;a href=&#34;https://en.wikipedia.org/wiki/Protocol_Buffers&#34;&gt;Protocol Buffers&lt;/a&gt; for binary encoding of commands, queries, and answers.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_channels&#34;&gt;Channels&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The channel decodes all commands send through it into a command instances.
The channel has knowledge of the command structure.
This is needed to decode the command and dispatch it to the right interpreter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This approach delegates the encoding and decoding of commands to messages to the channel.
This approach is the standard one for bus communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;exampleblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;You can implement a two-step decoding process for maximum flexibility.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The first step is to decode the message type and encodind format before dispatching the message to the right interpreter.
The interpreter will decode the message payload and transform it into a command instance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This approach shall only be used if you need to support multiple complex encoding formats due to its complexity.
Most decoding libraries for JSON, proto buffers, or command line parsers are ill-suited for this approach.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The payload of the message does not need to be interpreted by the channel.
This activity can be delegated to the interpreter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Consider using a factory pattern for the decoding operations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;If you are using the Google &lt;a href=&#34;https://en.wikipedia.org/wiki/Protocol_Buffers&#34;&gt;Protocol Buffers&lt;/a&gt; library, you will have to describe the structure of all messages send over the channel.
The library will generate the code to encode and decode the messages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The same can be said if your transmission format is &lt;a href=&#34;https://en.wikipedia.org/wiki/JSON&#34;&gt;JSON&lt;/a&gt; and you want to validate the structure of the messages with a &lt;a href=&#34;https://json-schema.org&#34;&gt;JSON Schema&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The above describes constraints are in line with how major encoding approaches are designed.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_thoughts&#34;&gt;Thoughts&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This design approach is almost codified as a design pattern.
The solution is constrained by the decision to use the compiler toolchain to validate the command types and to program the processing with a pattern matching approach.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This approach melts object-orientation with functional aspects.
It reflects the evolution of modern programming languages blending object-orientation and functional approaches.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_links&#34;&gt;Links&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist bibliography&#34;&gt;
&lt;ul class=&#34;bibliography&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-architecture-principles&#34;&gt;Agile Architecture Principles&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-code-is-clean-code&#34;&gt;Agile Code is Clean Code!&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2019/agile-architecture-within-scrum/&#34;&gt;Agile Architecture within Scrum&lt;/a&gt;
Marcel Baumann. 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/agile-component-design&#34;&gt;Agile Component Design&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/legacy-systems-refactoring&#34;&gt;Legacy Systems Refactoring&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../2020/how-agile-collaborators-learn&#34;&gt;How Agile Collaborators Learn&lt;/a&gt;
Marcel Baumann. 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;footnotes&#34;&gt;
&lt;hr/&gt;
&lt;div class=&#34;footnote&#34; id=&#34;_footnotedef_1&#34;&gt;
&lt;a href=&#34;#_footnoteref_1&#34;&gt;1&lt;/a&gt;. A powerful software quality approach is to delegate validation activities to the compiler.
&lt;/div&gt;
&lt;div class=&#34;footnote&#34; id=&#34;_footnotedef_2&#34;&gt;
&lt;a href=&#34;#_footnoteref_2&#34;&gt;2&lt;/a&gt;. Agile and DevOps approaches mitigate the problem. You should be able to generate a new version of your application in at most a few minutes without manual activities.
&lt;/div&gt;
&lt;/div&gt;

      </description>
    </item>
    
  </channel>
</rss>
