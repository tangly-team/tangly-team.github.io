<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Embedded on tangly Components</title>
    <link>https://blog.tangly.net/tags/embedded/</link>
    <description>Recent content in Embedded on tangly Components</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 02 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.tangly.net/tags/embedded/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Embedded Applications</title>
      <link>https://blog.tangly.net/blog/2024/embedded-applications/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.tangly.net/blog/2024/embedded-applications/</guid>
      <description>&lt;div class=&#34;imageblock left&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;img src=&#34;../pics/2024-09-01-head.jpg&#34; alt=&#34;2024 09 01 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;An embedded application is a software product placed permanently inside some kind of device to perform a very specific set of functions.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The software is typically specialized for particular hardware with a specific purpose that must meet time, size, energy, and memory constraints.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;As an example, some embedded applications are designed to run for months or years in a row without being turned off or receiving a reset command.&#xA;It is used in areas from agriculture to space probes and more.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Domain-Driven Design with ROS-2</title>
      <link>https://blog.tangly.net/blog/2024/domain-driven-design-with-ros-2/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.tangly.net/blog/2024/domain-driven-design-with-ros-2/</guid>
      <description>&lt;div class=&#34;imageblock left&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;img src=&#34;../pics/2024-08-02-head.png&#34; alt=&#34;2024 08 02 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;At its core, &lt;a href=&#34;https://www.ros.org/&#34;&gt;Robot Operation System&lt;/a&gt; provides a message-passing system, often called &lt;em&gt;middleware&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Communication is one of the first needs to arise when implementing a new robot application, or really any software system that will interact with hardware.&#xA;ROSâ€™s built-in and well-tested messaging system saves you time by managing the details of communication between distributed nodes via an anonymous &lt;a href=&#34;https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern&#34;&gt;Publish and Subscribe Pattern&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;This approach encourages good practices in your software development, including fault isolation, &lt;a href=&#34;https://en.wikipedia.org/wiki/Separation_of_concerns&#34;&gt;Seperation of Concerns&lt;/a&gt;, and clear interfaces.&#xA;Using ROS results in systems that are easier to maintain, contribute to, and reuse.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Actors with CMSIS OS in Cpp</title>
      <link>https://blog.tangly.net/blog/2024/actors-with-cmsis-os-in-cpp/</link>
      <pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.tangly.net/blog/2024/actors-with-cmsis-os-in-cpp/</guid>
      <description>&lt;div class=&#34;imageblock left&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;img src=&#34;../pics/2024-06-03-head.svg&#34; alt=&#34;2024 06 03 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The actor library defines the actor abstraction with mailboxes and concrete implementation for various target platforms.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://arm-software.github.io/CMSIS_5/RTOS2/html/index.html&#34;&gt;CMSIS-RTOS v2&lt;/a&gt; platform provides an actor implementation for all realtime kernels supporting the CMSIS API.&#xA;The API is under the stewardship of the ARM company.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Any kernel with a &lt;a href=&#34;https://arm-software.github.io/CMSIS_5/RTOS2/html/index.html&#34;&gt;CMSIS-RTOS v2&lt;/a&gt; compatible layer is eligible.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;STM provides the CMSIS integration with &lt;a href=&#34;https://www.freertos.org/index.html&#34;&gt;freeRTOS&lt;/a&gt; for all STM32 microcontrollers.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_library&#34;&gt;Library&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The library defines key abstractions as abstract classes &lt;a href=&#34;#actors&#34;&gt;[1]&lt;/a&gt; &lt;a href=&#34;#actors-in-cpp&#34;&gt;[2]&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Bus Sensors and Actuators</title>
      <link>https://blog.tangly.net/blog/2023/bus-sensors-and-actuators/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.tangly.net/blog/2023/bus-sensors-and-actuators/</guid>
      <description>&lt;div class=&#34;openblock float-group&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;div class=&#34;imageblock left&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;img src=&#34;../pics/2023-12-05-head.jpg&#34; alt=&#34;2023 12 05 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Your embedded system has a set of sensors and actors.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Some sensors and actors are connected to a bus.&#xA;Typical buses are &lt;a href=&#34;https://en.wikipedia.org/wiki/CAN_bus&#34;&gt;CAN bus&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;Serial Peripherical Interface&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet&#34;&gt;Ethernet&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Bluetooth&#34;&gt;Bluetooth&lt;/a&gt;, or &lt;a href=&#34;https://en.wikipedia.org/wiki/I%C2%B2C&#34;&gt;I2C&lt;/a&gt; standards.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The bus is a shared medium used to communicate with a set of external active or passive components.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Which design rules shall you follow when designing sensors and actors using a bus architecture?&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Do you need to consider threading design?&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Sensors and Actuators</title>
      <link>https://blog.tangly.net/blog/2023/sensors-and-actuators/</link>
      <pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.tangly.net/blog/2023/sensors-and-actuators/</guid>
      <description>&lt;div class=&#34;openblock float-group&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;div class=&#34;imageblock left&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;img src=&#34;../pics/2023-12-04-head.jpg&#34; alt=&#34;2023 12 04 head&#34; width=&#34;420&#34; height=&#34;360&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Embedded design maps domain abstractions to the underlying hardware.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;A temperature sensor is a domain abstraction of a physical hardware temperature sensor.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;A valve is a domain abstraction of a physical hardware valve.&#xA;A physical valve can be a simple opened-closed device, or a proportional device.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The microcontroller board reads the temperature sensor through an I2C or SPI bus.&#xA;It controls the valve through a GPIO, a PWM, or a CAN bus controller.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
